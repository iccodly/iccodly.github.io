# A. Not a Substring (00:08)
길이 $n$짜리 괄호 문자열이 주어진다. 이 문자열을 부분 문자열로 가지지 않는 길이 $2n$짜리 올바른 괄호 문자열을 구하여라.

다음의 두 종류 괄호 문자열을 생각할 수 있다.
1. (((((()))))): '('이 $n$개, ')'이 $n$개
2. ()()()()()(): "()"이 $n$개
만약 첫 번째 형태의 괄호 문자열에서 주어진 문자열이 나타난다면 '(' 또는 ')'이 2번 연속해서 나타나는 부분이 있다는 뜻이므로 2번째 형태의 문자열에서 나올 수 없다.
예외적으로 '()'이 주어진 경우에는 조건을 만족하는 올바른 괄호 문자열을 만들 수 없다.
# B. Fancy Coins (00:37, +1)
1불짜리 표준 동전 $a_1$개, $k$불짜리 표준 동전 $a_k$개가 있다. 1불 또는 $k$불짜리 멋진 동전은 충분히 많다고 가정한다. 정확히 $m$불을 내려고 할 때 멋진 동전을 가장 적게 쓰려고 한다. 멋진 동전을 최소한으로 내는 수를 구하여라.

$k$불짜리 표준 동전은 아무리 많아도 $\lfloor m/k\rfloor$개까지만 낼 수 있으니 많아야 $\lfloor m/k\rfloor$개만 있다고 생각할 수 있다. 이때 표준 동전의 총 가치가 $m$불 이상이라면 멋진 동전을 쓰지 않고 지불할 수 있다.
지불하는 멋진 동전의 수를 가장 적게 해야 하므로 1불짜리 표준 동전은 $k$불짜리 동전으로 지불한 뒤 남은 돈을 계산하는 데에 써야 한다. $m\%k$개의 1불짜리 표준 동전을 지불한 뒤에는 1불짜리 표준 동전이 $k$개 있을 때마다 지불한다. 모자라는 1불짜리 동전의 수와 $k$불짜리 동전의 수만큼 멋진 동전으로 지불한다.
# C. Game on Permutation (00:59)
Alice와 Bob은 길이 $n$짜리 순열로 게임을 한다. Alice가 처음에 칩을 놓을 곳을 정하고 Bob부터 차례를 번갈아가며 칩을 움직인다. 칩보다 앞에 있고 칩이 위에 있는 수보다 작은 수가 적힌 곳으로만 칩을 움직일 수 있다. 규칙에 맞게 칩을 움직일 수 없는 사람이 이긴다. Alice가 어떻게 칩을 움직이든 이길 수 있는 자리를 '운 좋은 자리'라고 한다. 운 좋은 자리의 수를 구하여라.

지금 자리에서 칩을 움직일 수 있는 자리가 없다면 그 자리는 내 차례에 도달했을 때 항상 지는 자리다. Alice가 어떤 움직임을 택하든 이길 수 있어야 하므로 운 좋은 자리는 움직일 수 있는 다른 자리가 있고 그 자리가 항상 지는 자리인 자리와 같다.
- 구현: 1번 자리부터 $n$번 자리까지 순서대로 세그먼트 트리에 넣는다. 현재 자리에서 갈 수 있는 자리의 수와 현재 자리에서 갈 수 있는 항상 지는 자리의 수가 같으면 운 좋은 자리다.

*다른 풀이: $i$번 자리가 운 좋은 자리라는 것은 $[1,\ i]$구간의 LIS의 길이가 2라는 것과 같다. Alice가 LIS의 다른 자리로 움직였을 때 Bob이 운 좋은 자리로 칩을 움직일 수 있기 때문에 어떻게 움직이든 승리한다는 보장이 없기 때문이다.*
# D. Balanced String (01:42)
길이 $n$짜리 이진 문자열 $s$가 주어진다. 균형 잡힌 문자열은 $0\le i,\ j<n$인 $(i,\ j)$에 대해 $s[i]=1,\ s[j]=0$인 순서쌍 $(i,\ j)$의 수와 $s[i]=0,\ s[j]=1$인 순서쌍 $(i,\ j)$의 수가 같은 문자열을 말한다. $s$를 균형 잡힌 문자열로 만들기 위해 두 문자의 자리를 바꾸어야 하는 최소 횟수를 구하여라.

$0\le i,\ j<n$인 $(i,\ j)$에 대해 $s[i]=1,\ s[j]=0$인 순서쌍 $(i,\ j)$을 '10 순서쌍'이라 하자. 10 순서쌍의 수를 $f$라 하면 길이가 $n$이고 1이 $m$개 있는 균형 잡힌 문자열에서 $f=\cfrac{m(n-m)}{2}$이다. $0\le i,\ j<n$인 $(i,\ j)$에 대해 $s[i]=1,\ s[j]=0$이라 하자. $i$번째 문자와 $j$번째 문자를 바꾸었을 때 10 순서쌍의 개수는 $j-i$개 감소한다. 구간 $[i+1,\ j-1]$에 있는 1의 개수를 $x$, 0의 개수를 $y$라 하면 $i$번 문자가 만드는 10순서쌍의 개수가 $x$개, $j$번 문자가 만드는 10 순서쌍의 개수가 $y$개만큼 없어지기 때문이다. 이때 $(i,\ j)$도 10 순서쌍이므로 10 순서쌍의 개수는 $x+y+1=(j-i-1)+1=j-i$개만큼 감소한다. 같은 방법으로 $s[i]=0,\ s[j]=1$인 경우 10 순서쌍의 개수는 $j-i$개 증가한다. 따라서 다음을 알 수 있다.
1. $i$번 자리의 $1$과 $j$번 자리의 0을 바꾸면 10 순서쌍의 개수는 $i-j$개만큼 변한다.
2. 각 자리의 수는 최대 1번 이동한다. 예를 들어 $i$번 자리의 1과 $j$번 자리의 0을 바꾼 뒤 $j$번 자리에 있는 1과 $k$번 자리에 있는 0을 다시 바꾸는 경우는 최적이 아니다. 처음에 $i$번 자리의 1과 $k$번 자리의 0을 바꾸는 것이 더 적은 수로 같은 변화를 만들 수 있기 때문이다($(i-j)+(j-k)=i-k$이므로).
각 문자를 바꿀 때 10 순서쌍의 수를 1은 자신의 인덱스만큼 늘리고 0은 자신의 인덱스만큼 줄인다. 따라서 처음 10 순서쌍의 개수를 $f_0$이라 하면 문제를 다음과 같이 바꿀 수 있다.
- 길이 $n$짜리 이진 문자열 $s$에서 (1이 있는 인덱스 중 서로 다른 $t$개의 합)-(0이 있는 인덱스 중 서로 다른 $t$개의 합)$=f-f_0$가 되도록 하는 가장 작은 $t$를 구하여라.
$dp(i,\ j),\ dp'(i,\ j)$를 다음과 같이 정의한다.
- $dp(i,\ j):$ 1이 있는 인덱스 중 서로 다른 $i$개를 골랐을 때 합이 $j$가 될 수 있으면 1, 될 수 없으면 0
- $dp'(i,\ j):$ 0이 있는 인덱스 중 서로 다른 $i$개를 골랐을 때 합이 $j$가 될 수 있으면 1, 될 수 없으면 0
주어지는 이진 문자열 $s$는 균형 잡힌 문자열로 만들 수 있으므로 2에 의해 최대 $\lfloor\cfrac{n}{2}\rfloor$번의 교환으로 균형 잡힌 문자열로 만들 수 있다. dp 테이블을 채우는 데 $O(n^4)$이 걸리고, 각 $t$에 대해 가능/불가능 여부를 판단하는 데 $O(n^2)$이 걸린다.
